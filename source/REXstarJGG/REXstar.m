function c = REXstar(Param, p)
% Function of REXstar (Real-coded Ensemble Crossover star)
% This function returns children generated by REXstar.
% 
% See "Kimura S, Sato M, Okada-Hatakeyama M: An Effective Method for the
% Inference of Reduced S-system Models of Genetic Networks. Information and
% Media Technologies 2015, 10(1):166-174.".
% 
% Recommended:
% n_population = 2*n_gene ~ 20*n_gene
% n_parent = n_gene + 1
% n_children = 2*n_gene ~ 3*n_gene
% t (Step-size parameter) = 2.5 ~ 15
% 
% Required:
% n_parent <= n_children

n_parent = Param.n_parent;
n_gene = Param.n_gene;
n_children = Param.n_children;
n_constraint = Param.n_constraint;
t = Param.t_rextar;
Pf = Param.Pf;
maxitr = 100;


if n_children < n_parent
    error('n_parent <= n_children must be satisfied!\n');
end
	
% Calculate center of gravity G
G.gene = zeros(1,n_gene);
for i = 1 : n_parent
    G.gene = G.gene + p(i).gene;
end
G.gene = G.gene / n_parent;

% Initialize children
c(1,1:n_children) = struct('gene',Inf(1,n_gene),'g',Inf(1,n_constraint),'f',Inf,'phi',Inf);

count = 0;
index = zeros(1,n_parent);
% Calculate reflection points (which are treated as the children)
for i = 1 : n_parent
    c(i).gene = 2.0 * G.gene - p(i).gene;
    if min( 0 <= c(i).gene & c(i).gene <= 1 )
        count = count + 1;
        index(count) = i;
    end
end
index = index(1:count);
c(index) = requestFitnessCalc(Param,c(index));

% Store parents and refrection points
r = [p c(1:n_parent)];
r = SRsort(r,Pf);

% Calculate center of gravity Gb
Gb.gene = zeros(1,n_gene);
for i = 1 : n_parent
    Gb.gene = Gb.gene + r(i).gene;
end
Gb.gene = Gb.gene / n_parent;

% Generate children
count = 0;
index = zeros(1,n_children);
for i = 1 : n_children
    flg_eval = 0;
    % If the generated child is out of range, re-generate a child
    for l = 0 : maxitr - 1
        flg_oob = 0;
        if max( c(i).gene < 0 | 1 < c(i).gene )
            flg_oob = 1;
        else
            break;
        end
        % Generation
        xi = t * rand(1,n_gene);
        c(i).gene = G.gene + xi .* ( Gb.gene - G.gene );
        for k = 1 : n_parent
            xi = 2.0 * sqrt( 3.0 / n_parent ) * rand - sqrt (3.0 / n_parent );
            c(i).gene = c(i).gene + xi .* ( p(k).gene - G.gene );
        end
        flg_eval = 1;
    end
    % If the generated child is out of range, alter the child
    if flg_oob == 1
        c(i).gene( c(i).gene < 0 ) = 0;
        c(i).gene( c(i).gene > 1 ) = 1;
        flg_eval = 1;
    end
    if flg_eval == 1
        count = count + 1;
        index(count) = i;
    end
end

index = index(1:count);
c(index) = requestFitnessCalc(Param,c(index));

c = SRsort(c,Pf);
